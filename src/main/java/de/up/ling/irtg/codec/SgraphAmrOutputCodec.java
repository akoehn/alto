/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.up.ling.irtg.codec;

import de.saar.basic.StringTools;
import de.up.ling.irtg.algebra.graph.GraphAlgebra;
import de.up.ling.irtg.algebra.graph.GraphEdge;
import de.up.ling.irtg.algebra.graph.GraphNode;
import de.up.ling.irtg.algebra.graph.SGraph;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * Encodes an s-graph as an AMR in the style of the ISI AMR-banks.
 * An example representation looks as follows:<p>
 * 
 * <code>(u_1 / boy  :ARG0-of (u_2 / want  :ARG1 (u_3 / go  :ARG0 u_1)))</code>
 * <p>
 * 
 * The string representation generated by this output codec
 * can be used as inputs to an IRTG with a {@link GraphAlgebra},
 * or parsed by a {@link IsiAmrInputCodec}.<p>
 * 
 * For compatibility with the original AMR format, this codec
 * never prints source names into the string representation,
 * even if the s-graph still has sources. If you want the source
 * names, see {@link SgraphAmrWithSourcesOutputCodec}.
 * 
 * @author koller
 */
@CodecMetadata(name = "amr-sgraph", description = "ISI-style AMR", type = SGraph.class)
public class SgraphAmrOutputCodec extends OutputCodec<SGraph> {

    boolean printSources = false;

    @Override
    public void write(SGraph sgraph, OutputStream ostream) throws IOException, UnsupportedOperationException {
        PrintWriter w = new PrintWriter(new OutputStreamWriter(ostream));
        final Set<GraphNode> visitedNodes = new HashSet<>();
        final Set<GraphEdge> visitedEdges = new HashSet<>();

        GraphNode u = sgraph.getGraph().vertexSet().iterator().next();
        toAmrVisit(u, sgraph, visitedNodes, visitedEdges, w);
        w.flush();

        if (!visitedNodes.containsAll(sgraph.getGraph().vertexSet())) {
            throw new UnsupportedOperationException("Graph cannot be represented as AMR: unvisited nodes.");
        }

        if (!visitedEdges.containsAll(sgraph.getGraph().edgeSet())) {
            throw new UnsupportedOperationException("Graph cannot be represented as AMR: unvisited edges.");
        }
    }

    private void toAmrVisit(GraphNode u, SGraph sgraph, Set<GraphNode> visitedNodes, Set<GraphEdge> visitedEdges, Writer out) throws IOException {
        if (visitedNodes.contains(u)) {
            out.write(u.getName());
        } else {
            boolean showName = false;
            boolean isSource = printSources && sgraph.isSourceNode(u.getName());

            visitedNodes.add(u);

            // determine whether node name is printed            
            showName = !u.getName().startsWith("_"); // ordinarily, suppress anonymous nodes

            // print node name
            if (showName) {
                out.write("(");
                out.write(p(u.getName()));
            }

            // print source names
            if (isSource) {
                out.write("<");
                out.write(StringTools.join(sgraph.getSourcesAtNode(u.getName()), ", "));
                out.write(">");
            }

            // print label
            if (u.getLabel() != null) {
                if (showName) {
                    out.write(" / ");
                }
                out.write(p(u.getLabel()));
            }

            for (GraphEdge e : sgraph.getGraph().outgoingEdgesOf(u)) {
                if (!visitedEdges.contains(e)) {
                    out.write("  :" + e.getLabel() + " ");
                    visitedEdges.add(e);
                    toAmrVisit(e.getTarget(), sgraph, visitedNodes, visitedEdges, out);
                }
            }

            for (GraphEdge e : sgraph.getGraph().incomingEdgesOf(u)) {
                if (!visitedEdges.contains(e)) {
                    out.write("  :" + e.getLabel() + "-of ");
                    visitedEdges.add(e);
                    toAmrVisit(e.getSource(), sgraph, visitedNodes, visitedEdges, out);
                }
            }

            if (showName) {
                out.append(")");
            }
        }
    }

    private static String p(String s) {
        if (TOKEN_PATTERN.matcher(s).matches()) {
            return s;
        } else {
            return "\"" + s + "\"";
        }
    }

    private static final Pattern TOKEN_PATTERN = Pattern.compile("[-a-zA-z0-9]+");

}
